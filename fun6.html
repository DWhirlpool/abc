<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Tornado ðŸŒª</title>
    </head>
    <body>
        <div class="container"></div>

        <script type="x-shader/x-fragment" id="fragmentShader">

        varying float vStripes;
        varying float vOpacity;

        void main() {
            gl_FragColor = vec4(vec3(vStripes * 15.), vOpacity);
        }

        </script>

        <script type="x-shader/x-vertex" id="vertexShader">

        #define PI 3.14159265359

        uniform float u_time;
        uniform float u_height;
        uniform float u_density;
        uniform float u_curl;
        uniform vec2 u_wind;
        uniform float u_mouse_delta;

        varying float vStripes;
        varying float vOpacity;

        vec2 random2(vec2 p) {
            return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
        }

        float voronoi(vec2 _uv, float time){
            vec2 i_uv = floor(_uv);
            vec2 f_uv = fract(_uv);
            float min_dist = 2.;
            for (int j = -1; j <= 1; j++) {
            for (int i = -1; i <= 1; i++) {
                vec2 tile_offset = vec2(float(i), float(j));
                vec2 cell_center = .5 + .5 * sin(time * .5 + PI * 2. * random2(i_uv + tile_offset));
                float dist = length(tile_offset + cell_center - f_uv);
                min_dist = min(min_dist, dist);
            }
            }
            return pow(min_dist, 2.);
        }

        mat2 rotate2d(float angle) {
            return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        }

        float cubic_pulse_shape(float center, float width, float x) {
            x = abs(x - center);
            if (x > width) return 0.;
            x /= width;
            return 1. - x * x * (3. - 2. * x);
        }

        float cone_shape(float x) {
            return .5 * cos(x * 3.1 + 2.6) + .5 + exp(-12. * x);
        }

        void main() {
            vec3 pos = position;
            float y_factor = uv.x;

            // Less visibile on right and back
            float vertical_transparency = pow(3. * y_factor * (1. - y_factor), 2.5);
            float back_transparency = pow(pos.x + 1., 2.) * pow(pos.z + 1., 2.);
            vOpacity = vertical_transparency * back_transparency;

            // Spiral stuuf over the cyllinder
            vec2 voronoi_point = vec2(atan(pos.x, pos.z) - pos.y * u_curl, pos.y - u_time);
            float bumps = voronoi(u_density * voronoi_point, u_time);
            vec3 pos_no_bump = pos;
            pos -= (normal * .2 * bumps);
            vStripes = length(pos_no_bump - pos);

            // Shaping the cyllinder
            float cone = cone_shape(y_factor);
            pos.x *= cone;
            pos.z *= cone;
            pos.y *= u_height;

            // Add slight constant rotation for central part
            vec2 wind = vec2(.04, 0.);
            wind = rotate2d(u_time * 2.) * wind;
            pos += (vec3(wind.x, 0., wind.y) * (1. - cone));

            // Make the central part to follow the mouse
            wind += u_wind;
            pos += vec3(wind.x, 0., wind.y) * cubic_pulse_shape(.35, .8, y_factor);

            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);
        }
        </script>
        <script>
            import * as THREE from "https://cdn.skypack.dev/three@0.133.1/build/three.module";
import { GUI } from "https://cdn.skypack.dev/lil-gui@0.16.1";

const container = document.querySelector('.container');

const config = {
    height: 1.1,
    density: 2.5,
    curl: 12,
};

class Controls {
    constructor() {
        const gui = new GUI();
        if (window.innerWidth < 600) gui.close();

        gui.add(config, 'height', 1, 1.8).step(.01).onChange(v => {
            viz.material.uniforms.u_height.value = v;
        });
        gui.add(config, 'density', 1, 4).step(.1).onChange(v => {
            viz.material.uniforms.u_density.value = v;
        });
        gui.add(config, 'curl', 4, 20).step(.1).onChange(v => {
            viz.material.uniforms.u_curl.value = v;
        });
    }
}

class Viz {

    constructor() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      
        container.appendChild(this.renderer.domElement);

        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        this.camera.position.z = 2.9;
        this.camera.position.y = 1.1;
        this.camera.lookAt(0, 0, 0);

        this.rotationY = -.4 * Math.PI;

        this.raycaster = new THREE.Raycaster();

        this.mouse = new THREE.Vector2(0, 0);
        this.mouseTarget = new THREE.Vector2(0, 0);

        this.clock = new THREE.Clock();

        this.setupScene();
        this.render();
    }

    setupScene() {

        const planeMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff
        });
        const planeGeometry = new THREE.PlaneGeometry(2000, 1000);
        this.floor = new THREE.Mesh(planeGeometry, planeMaterial);
        this.floor.position.set(0, -2, 0);
        this.floor.rotation.set(-.2 * Math.PI, 0, 0);
        this.scene.add(this.floor);

        this.material = new THREE.ShaderMaterial({
            uniforms: {
                u_time: { type: 'f', value: 0 },
                u_height: { type: 'f', value: config.height },
                u_density: { type: 'f', value: config.density },
                u_curl: { type: 'f', value: config.curl },
                u_wind: { type: 'v2', value: new THREE.Vector2(0, 0) },
            },
            vertexShader: document.getElementById("vertexShader").textContent,
            fragmentShader: document.getElementById("fragmentShader").textContent,
            side: THREE.DoubleSide,
            transparent: true
        });
        const curve = new THREE.LineCurve3(
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 1, 0),
        );
        const geometry = new THREE.TubeGeometry(curve, 512, .55, 512, false);
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.position.set(0, -.65, 0);
        this.mesh.rotation.set(0, this.rotationY, 0);
        this.scene.add(this.mesh);
    }


    addCanvasEvents() {
        container.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY, this);
        });
        container.addEventListener('touchmove', (e) => {
            updateMousePosition(e.touches[0].pageX, e.touches[0].pageY, this);
        });
		

        function updateMousePosition(eX, eY, viz) {
            const x = eX - container.offsetLeft;
            const y = eY - container.offsetTop;
            viz.mouseTarget.x = x / container.offsetWidth * 2 - 1;
            viz.mouseTarget.y = -(y / container.offsetHeight) * 2 + 1;
        }
    }

    render() {
        this.material.uniforms.u_time.value = 1.3 * this.clock.getElapsedTime();

        this.mouse.x += (this.mouseTarget.x - this.mouse.x) * .1;
        this.mouse.y += (this.mouseTarget.y - this.mouse.y) * .1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObject(this.floor);
        if (intersects.length) {
            this.material.uniforms.u_wind.value = new THREE.Vector2(intersects[0].uv.x - .5, .5 - intersects[0].uv.y)
                .rotateAround(new THREE.Vector2(0, 0), this.rotationY)
                .multiplyScalar(200);
        }

        this.renderer.render(this.scene, this.camera);
    }

    loop() {
        this.render();
        requestAnimationFrame(this.loop.bind(this));
    }

    updateSize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}


const controls = new Controls();
const viz = new Viz();
viz.addCanvasEvents();
viz.updateSize();
viz.loop();

window.addEventListener('resize', () => viz.updateSize());
        </script>
        <style>
            body {
    overflow: hidden;
    padding: 0;
    margin: 0;
}
canvas {
    display: block;
}
        </style>
    </body>
</html>